#pragma once

#include <Arduino.h>
#include <FastLED.h>

#include "bleControl.h"

namespace bubble {

bool bubbleInstance = false;

namespace bubble_detail {

class BubbleEffect {
private:
    uint8_t width, height;
    CRGB* leds;
    uint16_t (*xyFunc)(uint8_t x, uint8_t y);
    
    int8_t zD;
    int8_t zF;
    uint8_t** noise3d;
    uint32_t noise32_x;
    uint32_t noise32_y;
    uint32_t noise32_z;
    uint32_t scale32_x;
    uint32_t scale32_y;
    bool isSetup = true;
    uint8_t noisesmooth;
    uint16_t mov;

public:
    BubbleEffect(uint8_t w, uint8_t h, CRGB* ledArray, uint16_t (*xyFunction)(uint8_t, uint8_t))
        : width(w), height(h), leds(ledArray), xyFunc(xyFunction) {
        
        // Allocate 2D noise array
        noise3d = new uint8_t*[width];
        for(uint8_t i = 0; i < width; i++) {
            noise3d[i] = new uint8_t[height];
        }
        
        mov = max(width, height) * 47;
        noisesmooth = 200;  // Default smoothing value
    }
    
    ~BubbleEffect() {
        // Clean up 2D array
        for(uint8_t i = 0; i < width; i++) {
            delete[] noise3d[i];
        }
        delete[] noise3d;
    }

    void FillNoise() {
        for (uint8_t i = 0; i < width; i++) {
            int32_t ioffset = scale32_x * (i - width / 2);
            for (uint8_t j = 0; j < height; j++) {
                int32_t joffset = scale32_y * (j - height / 2);
                int8_t data = inoise16(noise32_x + ioffset, noise32_y + joffset, noise32_z) >> 8;
                int8_t olddata = noise3d[i][j];
                int8_t newdata = scale8(olddata, noisesmooth) + scale8(data, 255 - noisesmooth);
                data = newdata;
                noise3d[i][j] = data;
            }
        }
    }

    void MoveFractionalNoiseX(int8_t amplitude = 1, float shift = 0) {
        CRGB ledsbuff[width];
        for (uint8_t y = 0; y < height; y++) {
            int16_t amount = ((int16_t) noise3d[0][y] - 128) * 2 * amplitude + shift * 256;
            int8_t delta = abs(amount) >> 8;
            int8_t fraction = abs(amount) & 255;
            for (uint8_t x = 0; x < width; x++) {
                if (amount < 0) {
                    zD = x - delta;
                    zF = zD - 1;
                } else {
                    zD = x + delta;
                    zF = zD + 1;
                }
                CRGB PixelA = CRGB::Black;
                if ((zD >= 0) && (zD < width)) {
                    PixelA = leds[xyFunc(zD, y)];
                } else {
                    PixelA = CHSV(~noise3d[abs(zD)%width][y]*3,255,255);
                }
                CRGB PixelB = CRGB::Black;
                if ((zF >= 0) && (zF < width)) {
                    PixelB = leds[xyFunc(zF, y)]; 
                } else {
                    PixelB = CHSV(~noise3d[abs(zF)%width][y]*3,255,255);
                }
                ledsbuff[x] = (PixelA.nscale8(ease8InOutApprox(255 - fraction))) + (PixelB.nscale8(ease8InOutApprox(fraction)));
            }
            for (uint8_t x = 0; x < width; x++) {
                leds[xyFunc(x, y)] = ledsbuff[x];
            }
        }
    }

    void MoveFractionalNoiseY(int8_t amplitude = 1, float shift = 0) {
        CRGB ledsbuff[height];
        for (uint8_t x = 0; x < width; x++) {
            int16_t amount = ((int16_t) noise3d[x][0] - 128) * 2 * amplitude + shift * 256;
            int8_t delta = abs(amount) >> 8;
            int8_t fraction = abs(amount) & 255;
            for (uint8_t y = 0; y < height; y++) {
                if (amount < 0) {
                    zD = y - delta;
                    zF = zD - 1;
                } else {
                    zD = y + delta;
                    zF = zD + 1;
                }
                CRGB PixelA = CRGB::Black;
                if ((zD >= 0) && (zD < height)) {
                    PixelA = leds[xyFunc(x, zD)];
                } else {
                    PixelA = CHSV(~noise3d[x][abs(zD)%height]*3,255,255);
                }
                CRGB PixelB = CRGB::Black;
                if ((zF >= 0) && (zF < height)) {
                    PixelB = leds[xyFunc(x, zF)];
                } else {
                    PixelB = CHSV(~noise3d[x][abs(zF)%height]*3,255,255);
                }
                ledsbuff[y] = (PixelA.nscale8(ease8InOutApprox(255 - fraction))) + (PixelB.nscale8(ease8InOutApprox(fraction)));
            }
            for (uint8_t y = 0; y < height; y++) {
                leds[xyFunc(x, y)] = ledsbuff[y];
            }
        }
    }

    void run() {
        if (isSetup) {
            noise32_x = random16();
            noise32_y = random16();
            noise32_z = random16();
            scale32_x = (160000/width) * cZoom;   // Apply zoom parameter
            scale32_y = (160000/height) * cZoom;  // Apply zoom parameter
            FillNoise();
            for (byte i = 0; i < width; i++) {
                for (byte j = 0; j < height; j++) {
                    leds[xyFunc(i, j)] = CHSV(~noise3d[i][j]*3, 255, cBright);  // Use BLE brightness
                }
            }
            isSetup = false;
        }
        
        // Apply speed parameter to movement
        uint32_t moveSpeed = mov * cSpeed;
        noise32_x += moveSpeed;
        noise32_y += moveSpeed; 
        noise32_z += moveSpeed;
        
        // Apply scale parameters
        scale32_x = (160000/width) * cZoom * cScale;
        scale32_y = (160000/height) * cZoom * cScale;
        
        FillNoise();
        FastLED.delay(5);
        MoveFractionalNoiseX(width/8 * cRadius);   // Use radius for amplitude
        MoveFractionalNoiseY(height/8 * cRadius);  // Use radius for amplitude
    }
    
    void reset() {
        isSetup = true;
    }
};

} // namespace bubble_detail

// Global instance for interface functions
bubble_detail::BubbleEffect* bubbleEffectInstance = nullptr;

void initBubble(uint8_t width, uint8_t height, CRGB* leds, uint16_t (*xy_func)(uint8_t, uint8_t)) {
    bubbleInstance = true;
    
    if (bubbleEffectInstance) {
        delete bubbleEffectInstance;
    }
    bubbleEffectInstance = new bubble_detail::BubbleEffect(width, height, leds, xy_func);
}

void runBubble() {
    if (bubbleEffectInstance) {
        bubbleEffectInstance->run();
    }
}

} // namespace bubble